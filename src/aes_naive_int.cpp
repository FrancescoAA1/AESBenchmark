#include "../include/aes_naive_int.h"

// ===================== S-box / Inv S-box / Rcon =====================

static const AES128Words::u8 SBOX[256] = {
  // 0x00 .. 0x0F
  0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
  // 0x10 ..
  0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
  0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
  0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
  0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
  0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
  0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
  0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
  0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
  0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
  0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
  0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
  0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
  0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
  0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
  0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16
};

static const AES128Words::u8 INV_SBOX[256] = {
  0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,
  0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,
  0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,
  0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,
  0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,
  0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,
  0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,
  0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,
  0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,
  0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,
  0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,
  0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,
  0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,
  0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,
  0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,
  0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D
};

static const AES128Words::u8 RCON[11] = {
    0x00, // unused (round 0)
    0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36
};

// ===================== Inline helpers =====================

inline AES128Words::u8 AES128Words::sbox(u8 x)      { return SBOX[x]; }
inline AES128Words::u8 AES128Words::inv_sbox(u8 x)  { return INV_SBOX[x]; }
inline AES128Words::u8 AES128Words::xtime(u8 x)     { return (u8)((x<<1) ^ (0x1B & (-(x>>7)))); }

inline AES128Words::u8 AES128Words::gf_mul(u8 a, u8 b) {
    // Generic GF(2^8) multiply used for inverse MixColumns.
    u8 res = 0;
    for (int i=0; i<8; ++i) {
        if (b & 1) res ^= a;
        u8 hi = a & 0x80;
        a <<= 1;
        if (hi) a ^= 0x1B;
        b >>= 1;
    }
    return res;
}

inline AES128Words::u32 AES128Words::pack(u8 r0,u8 r1,u8 r2,u8 r3) {
    return (u32(r0)<<24) | (u32(r1)<<16) | (u32(r2)<<8) | u32(r3);
}
inline AES128Words::u8 AES128Words::b0(u32 w){ return (u8)(w>>24); }
inline AES128Words::u8 AES128Words::b1(u32 w){ return (u8)(w>>16); }
inline AES128Words::u8 AES128Words::b2(u32 w){ return (u8)(w>> 8); }
inline AES128Words::u8 AES128Words::b3(u32 w){ return (u8)(w>> 0); }

inline AES128Words::u32 AES128Words::sub_bytes_word(u32 w){
    return pack(sbox(b0(w)), sbox(b1(w)), sbox(b2(w)), sbox(b3(w)));
}

inline void AES128Words::sub_bytes(Block4x32 &S){
    S[0] = sub_bytes_word(S[0]);
    S[1] = sub_bytes_word(S[1]);
    S[2] = sub_bytes_word(S[2]);
    S[3] = sub_bytes_word(S[3]);
}

inline void AES128Words::shift_rows(Block4x32 &S){
    u32 c0=S[0], c1=S[1], c2=S[2], c3=S[3];
    // Row0 unchanged
    u8 r00=b0(c0), r01=b0(c1), r02=b0(c2), r03=b0(c3);
    // Row1 shift left by 1
    u8 r10=b1(c1), r11=b1(c2), r12=b1(c3), r13=b1(c0);
    // Row2 shift left by 2
    u8 r20=b2(c2), r21=b2(c3), r22=b2(c0), r23=b2(c1);
    // Row3 shift left by 3 (right by 1)
    u8 r30=b3(c3), r31=b3(c0), r32=b3(c1), r33=b3(c2);

    S[0] = pack(r00,r10,r20,r30);
    S[1] = pack(r01,r11,r21,r31);
    S[2] = pack(r02,r12,r22,r32);
    S[3] = pack(r03,r13,r23,r33);
}

inline AES128Words::u32 AES128Words::mix_column(u32 w){
    // Uses GMUL2=xtime(x), GMUL3=xtime(x)^x
    u8 a0=b0(w), a1=b1(w), a2=b2(w), a3=b3(w);
    u8 a0_2 = xtime(a0), a1_2 = xtime(a1), a2_2 = xtime(a2), a3_2 = xtime(a3);
    u8 a0_3 = (u8)(a0_2 ^ a0), a1_3 = (u8)(a1_2 ^ a1), a2_3 = (u8)(a2_2 ^ a2), a3_3 = (u8)(a3_2 ^ a3);

    u8 r0 = (u8)(a0_2 ^ a1_3 ^ a2 ^ a3);
    u8 r1 = (u8)(a0 ^ a1_2 ^ a2_3 ^ a3);
    u8 r2 = (u8)(a0 ^ a1 ^ a2_2 ^ a3_3);
    u8 r3 = (u8)(a0_3 ^ a1 ^ a2 ^ a3_2);
    return pack(r0,r1,r2,r3);
}

inline void AES128Words::mix_columns(Block4x32 &S){
    S[0] = mix_column(S[0]);
    S[1] = mix_column(S[1]);
    S[2] = mix_column(S[2]);
    S[3] = mix_column(S[3]);
}

inline void AES128Words::add_round_key(Block4x32 &S, const RoundKey4x32 &RK){
    S[0] ^= RK[0];
    S[1] ^= RK[1];
    S[2] ^= RK[2];
    S[3] ^= RK[3];
}

// ----- Inverse -----

inline AES128Words::u32 AES128Words::inv_mix_column(u32 w){
    // Multiply by {0e,0b,0d,09} per AES spec using generic gf_mul.
    u8 a0=b0(w), a1=b1(w), a2=b2(w), a3=b3(w);
    u8 r0 = (u8)(gf_mul(a0,0x0e)^gf_mul(a1,0x0b)^gf_mul(a2,0x0d)^gf_mul(a3,0x09));
    u8 r1 = (u8)(gf_mul(a0,0x09)^gf_mul(a1,0x0e)^gf_mul(a2,0x0b)^gf_mul(a3,0x0d));
    u8 r2 = (u8)(gf_mul(a0,0x0d)^gf_mul(a1,0x09)^gf_mul(a2,0x0e)^gf_mul(a3,0x0b));
    u8 r3 = (u8)(gf_mul(a0,0x0b)^gf_mul(a1,0x0d)^gf_mul(a2,0x09)^gf_mul(a3,0x0e));
    return pack(r0,r1,r2,r3);
}

inline void AES128Words::inv_mix_columns(Block4x32 &S){
    S[0] = inv_mix_column(S[0]);
    S[1] = inv_mix_column(S[1]);
    S[2] = inv_mix_column(S[2]);
    S[3] = inv_mix_column(S[3]);
}

inline void AES128Words::inv_shift_rows(Block4x32 &S){
    u32 c0=S[0], c1=S[1], c2=S[2], c3=S[3];
    // Row0 unchanged
    u8 r00=b0(c0), r01=b0(c1), r02=b0(c2), r03=b0(c3);
    // Row1 right by 1
    u8 r10=b1(c3), r11=b1(c0), r12=b1(c1), r13=b1(c2);
    // Row2 right by 2
    u8 r20=b2(c2), r21=b2(c3), r22=b2(c0), r23=b2(c1);
    // Row3 right by 3 (left by 1)
    u8 r30=b3(c1), r31=b3(c2), r32=b3(c3), r33=b3(c0);

    S[0] = pack(r00,r10,r20,r30);
    S[1] = pack(r01,r11,r21,r31);
    S[2] = pack(r02,r12,r22,r32);
    S[3] = pack(r03,r13,r23,r33);
}

inline void AES128Words::inv_sub_bytes(Block4x32 &S){
    S[0] = pack(inv_sbox(b0(S[0])), inv_sbox(b1(S[0])), inv_sbox(b2(S[0])), inv_sbox(b3(S[0])));
    S[1] = pack(inv_sbox(b0(S[1])), inv_sbox(b1(S[1])), inv_sbox(b2(S[1])), inv_sbox(b3(S[1])));
    S[2] = pack(inv_sbox(b0(S[2])), inv_sbox(b1(S[2])), inv_sbox(b2(S[2])), inv_sbox(b3(S[2])));
    S[3] = pack(inv_sbox(b0(S[3])), inv_sbox(b1(S[3])), inv_sbox(b2(S[3])), inv_sbox(b3(S[3])));
}

// ===================== Key expansion (AES-128) =====================

AES128Words::RoundKey4x32 AES128Words::make_roundkey_from_words(u32 w0,u32 w1,u32 w2,u32 w3){
    return RoundKey4x32{w0,w1,w2,w3};
}

void AES128Words::expand_key_128(const u8 key[16]){
    // AES-128: 44 words W[0..43]; every 4 words form a round key (11 keys).
    u32 W[44];
    // pack initial key (big-endian per word)
    for(int i=0;i<4;++i){
        int k = 4*i;
        W[i] = pack(key[k], key[k+1], key[k+2], key[k+3]);
    }
    auto subword = [&](u32 w)->u32{
        return pack(sbox(b0(w)), sbox(b1(w)), sbox(b2(w)), sbox(b3(w)));
    };
    auto rotword = [&](u32 w)->u32{
        // [b0,b1,b2,b3] -> [b1,b2,b3,b0]
        return pack(b1(w), b2(w), b3(w), b0(w));
    };

    for(int i=4, r=1; i<44; ++i){
        u32 temp = W[i-1];
        if (i % 4 == 0) {
            temp = subword(rotword(temp)) ^ (u32(RCON[r])<<24);
            ++r;
        }
        W[i] = W[i-4] ^ temp;
    }

    // store into rk_
    for(int round=0; round<=10; ++round){
        rk_[round] = make_roundkey_from_words(W[4*round+0], W[4*round+1], W[4*round+2], W[4*round+3]);
    }
}

// ===================== Public API =====================

AES128Words::AES128Words(const u8 key[16]){
    expand_key_128(key);
}

AES128Words::Block4x32 AES128Words::bytes_to_words_be(const u8 in[16]){
    Block4x32 S{};
    // columns are consecutive 4 bytes
    for(int c=0;c<4;++c){
        int k = 4*c;
        S[c] = pack(in[k+0], in[k+1], in[k+2], in[k+3]);
    }
    return S;
}

void AES128Words::words_to_bytes_be(const Block4x32 &state, u8 out[16]){
    for(int c=0;c<4;++c){
        int k=4*c;
        out[k+0]=b0(state[c]);
        out[k+1]=b1(state[c]);
        out[k+2]=b2(state[c]);
        out[k+3]=b3(state[c]);
    }
}

void AES128Words::encrypt(Block4x32 &S) const {
    add_round_key(S, rk_[0]);
    for (int r = 1; r < 10; ++r) {
        sub_bytes(S);
        shift_rows(S);
        mix_columns(S);
        add_round_key(S, rk_[r]);
    }
    sub_bytes(S);
    shift_rows(S);
    add_round_key(S, rk_[10]);
}

void AES128Words::decrypt(Block4x32 &S) const {
    add_round_key(S, rk_[10]);
    for (int r = 9; r >= 1; --r) {
        inv_shift_rows(S);
        inv_sub_bytes(S);
        add_round_key(S, rk_[r]);
        // Inverse MixColumns for rounds 1..9
        inv_mix_columns(S);
    }
    inv_shift_rows(S);
    inv_sub_bytes(S);
    add_round_key(S, rk_[0]);
}

void AES128Words::encrypt_bytes(const u8 in[16], u8 out[16]) const {
    Block4x32 S = bytes_to_words_be(in);
    encrypt(S);
    words_to_bytes_be(S, out);
}

void AES128Words::decrypt_bytes(const u8 in[16], u8 out[16]) const {
    Block4x32 S = bytes_to_words_be(in);
    decrypt(S);
    words_to_bytes_be(S, out);
}
